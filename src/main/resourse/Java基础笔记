主要记录一些JAVA的基础知识
# 【基础部分】
1、String 无法被继承 同样 包装类型也无法被继承 都有final修饰符
2、使用String str = "1" 为调用String.valueOf(1)来创建对象 使用 String str = new String("1") 为调用String构造器来创建对象
3、String 是不可变的 改变String的值只是创建一个新的String对象并改变引用
4、StringBuffer 线程安全 StringBuilder 线程不安全的 都有final修饰符
5、类加载过程大概分为五个阶段 加载 -> 链接（验证+准备+解析）-> 初始化 -> 使用 -> 卸载
    （1）加载
        通过类的全限定名获取字节流，转化为方法去运行时数据结构，生成Class对象（堆中）
    （2）链接
        验证：确保被加载类的正确性
        准备：为类的静态变量分配内存，并初始化默认值（赋值操作在此时不会进行 在初始化时进行）
        解析：把类中的符号引用转化为直接引用
    （3）初始化
        只有使用到的时候才进行初始化
        静态变量、静态初始化块 -> 变量、初始化块 -> 构造器
        如果有父类 父类static方法 -> 子类static方法 -> 父类构造方法 -> 子类构造方法

# 【算法部分】
1、红黑树

# 【容器相关】
1、ArrayList与LinkedList都实现了List接口 ArrayList基于数组 LinkedList基于链表 使用Node来管理
2、HashMap是采用 数组 + 链表 + 红黑树（JDK1.8新增）实现 链表长度大于8时会转换为红黑树
    数组：Node[] table 哈希筒数组 长度默认16 负载因子默认0.75


# 【IO相关】
    io是面向流的，是就用多少拿多少。是阻塞的。数据量不大的或者不在意阻塞的时可以用。
    nio是面向块的，先把数据搬过来，先存到缓存区里面，如果线程要用从缓存区拿。所以线程不需要时刻盯着io了，可以先做一些其他的事情，过几天再来看一下缓存。是同步非阻塞的。
    因此，nio里有Buffer类作为缓冲区，Channel(通道)相当于io里的steam的抽象，Selector是nio提供的管理多个Channel的工具。nio出现也是因为io渐渐成为一些程序速度的瓶颈。
    aio加了一个异步的特性。当我们要拿数据花费时间太长的时候，我们可以考虑使用异步的io。异步就是可以理解为，让io先处理者，我线程先去干别的事情了，你io处理完了通知我一下。
    aio提供的事件处理接口CompletionHandler，定义了回调函数，这些函数再io完成后会被自动的调用。

作者：rail gun
链接：https://www.zhihu.com/question/40930889/answer/146567853
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 【多线程相关】

# 【JVM相关】