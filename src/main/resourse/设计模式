# 策略模式
    策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户
    以鸭子模拟器举例 将飞行行为和鸣叫行为作为基类的接口，表示鸭子具有飞行和鸣叫的行为，通过调用接口的飞行和鸣叫方法切换行为方式
    子类通过构造器构造不同的飞行行为和鸣叫行为实现，还可以在运行时通过切换接口的实现改变行为方式
    详见 strategy 包下的MiniDuckSimulator例子

# 观察者模式
    观察者主要包括主题和观察者两个角色
    主题接口需要有观察者注册 观察者移除 观察者通知 3个方法 可以使用List<Object> 保存所订阅该主题的观察者，每当主题要新的变更，
    可以循环自己保存的观察者列表调用其通知方法达到广播的效果。
    观察者需要包含主题和消息通知方法 可以通过主题的观察者移除方法移除自己。
    java.util.Observer为JAVA内置的观察者模式 主题类继承Observable类 观察者实现 Observer 接口的 update() 方法
    详见 observer 包下的WeatherStation

# 装饰着模式
    可以动态的将责任附加到对象上 装饰着和被装饰着继承自同一个超类，装饰着可以作为被装饰者的替代 装饰着通过重写并调用被装饰者的方法来达到替代被装饰者的效果
    拿咖啡做例子 所有的类都继承自Beverage 使用调料类对饮料类进行装饰，重写父类的cost方法，每次加上自己的价格 构造器传入父类对象，实际使用时传入需要装饰的对象
    java中使用装饰着模式的为java的I/O类
    详见 decorate 包下的 StarbucksCoffee (A B Test 类表明了重写方法的效果)

# 工厂模式
    简单工厂 就是使用一个类根据不同条件来创建所需要的具体类型，简单工厂并不是一种模式，而是一种编程习惯
    工厂方法模式 定义了一个创建对象的接口 由子类决定要实例化的类是哪一个，工厂方法让类吧实例化推迟到子类
    抽象工厂模式 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
    工厂方法和抽象工厂之间的异同
    工厂方法使用的是继承 不同的子类工厂继承自同一个父类工厂，并覆盖父类工厂的方法，实现自己差异化的方法
    抽象工厂使用的是组合 接口定义具体的创建方法 缺点是新增需要修改接口，所有子类都会受影响
    详见 factory 包下的相关例子

# 单例模式
    创建单个实例 注意多线程
