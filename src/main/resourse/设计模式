# 策略模式
    策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户
    以鸭子模拟器举例 将飞行行为和鸣叫行为作为基类的接口，表示鸭子具有飞行和鸣叫的行为，通过调用接口的飞行和鸣叫方法切换行为方式
    子类通过构造器构造不同的飞行行为和鸣叫行为实现，还可以在运行时通过切换接口的实现改变行为方式
    详见 strategy 包下的MiniDuckSimulator例子

# 观察者模式
    观察者主要包括主题和观察者两个角色
    主题接口需要有观察者注册 观察者移除 观察者通知 3个方法 可以使用List<Object> 保存所订阅该主题的观察者，每当主题要新的变更，
    可以循环自己保存的观察者列表调用其通知方法达到广播的效果。
    观察者需要包含主题和消息通知方法 可以通过主题的观察者移除方法移除自己。
    java.util.Observer为JAVA内置的观察者模式 主题类继承Observable类 观察者实现 Observer 接口的 update() 方法
    详见 observer 包下的WeatherStation

# 装饰着模式
    可以动态的将责任附加到对象上 装饰着和被装饰着继承自同一个超类，装饰着可以作为被装饰者的替代 装饰着通过重写并调用被装饰者的方法来达到替代被装饰者的效果
    拿咖啡做例子 所有的类都继承自Beverage 使用调料类对饮料类进行装饰，重写父类的cost方法，每次加上自己的价格 构造器传入父类对象，实际使用时传入需要装饰的对象
    java中使用装饰着模式的为java的I/O类
    详见 decorate 包下的 StarbucksCoffee (A B Test 类表明了重写方法的效果)

# 工厂模式


